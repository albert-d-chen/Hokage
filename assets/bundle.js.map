{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/game.js","webpack:///./lib/main.js","webpack:///./lib/obstacle.js","webpack:///./lib/player.js","webpack:///./lib/score.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,eAAe,mBAAO,CAAC,iCAAU;AACjC,iBAAiB,mBAAO,CAAC,qCAAY;AACrC,cAAc,mBAAO,CAAC,+BAAS;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uB;AACA;AACA;AACA,G;AACA;;AAEA;;;;;;;;;;;;;ACvHA,eAAe,mBAAO,CAAC,oCAAa;AACpC,aAAa,mBAAO,CAAC,gCAAW;;;AAGhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;;;;;;;;;;;ACdD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,0B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kB;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,0B;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3HA,a;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uB","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/main.js\");\n","const Player = require('./player');\nconst Obstacle = require('./obstacle');\nconst Score = require('./score');\n\nclass Game {\n  constructor(ctx, gameCanvas) {\n    this.ctx = ctx;\n    this.gameCanvas = gameCanvas;\n\n    this.player = new Player();\n    this.obstacle = new Obstacle();\n\n    this.score = new Score();\n\n    this.playerDown = false;\n\n    this.count = 1000;\n    this.registerEvents();\n    this.gameStartMenu = this.gameStartMenu.bind(this);\n    // this.restartGame();\n    // this.restartGame = this.restartGame.bind(this);\n  }\n\n  play() {\n    console.log(\"play\");\n    this.running = true;\n    this.animate();\n  }\n\n  registerEvents() {\n    this.boundClickHandler = this.click.bind(this);\n    this.gameCanvas.addEventListener(\"mousedown\", this.boundClickHandler);\n    document.addEventListener(\"keydown\", (event) => {\n      if (event.code === \"Space\") {\n        this.player.jumping = true;\n      }\n    });\n    this.restart = this.restartGame.bind(this);\n    document.addEventListener(\"keydown\", this.restart);\n  }\n\n  click(e) {\n    if (!this.running && !this.gameOver()) {\n      this.play();\n    }\n  }\n\n  gameOver() {\n    return this.obstacle.checkCollision(this.player.playerHitBox());\n  }\n\n  restartGame(e) {\n    // debugger\n    if (e.key === \"l\" && this.gameOver()) {\n      this.score = new Score();\n      this.player = new Player();\n      this.obstacle = new Obstacle();\n      e.preventDefault();\n      this.animate();\n    }\n  }\n\n  gameOverMenu() {\n    const gameover = \"GAME OVER\";\n    const tryagain = \"Press L to accept defeat and try again\";\n    this.ctx.font = \"50px Naruto\";\n    this.ctx.strokeStyle = \"red\";\n    this.ctx.fillStyle = \"red\";\n    this.ctx.strokeText(gameover, 230, 150);\n    this.ctx.fillText(gameover, 230, 150);\n    this.ctx.font = \"30px Naruto\";\n    this.ctx.strokeText(tryagain, 60, 200);\n    this.ctx.fillText(tryagain, 60, 200);\n  }\n\n  gameStartMenu() {\n    // this.count--;\n    // if (this.count % 2 === 1) {\n      const gameover = \"CLICK TO PLAY\";\n      this.ctx.font = \"50px Naruto\";\n      this.ctx.strokeStyle = \"white\";\n      this.ctx.fillStyle = \"white\";\n      this.ctx.strokeText(gameover, 170, 200);\n      this.ctx.fillText(gameover, 170, 200);\n    // } else {\n    //     this.ctx.fillStyle = 'black'\n    //     this.ctx.fillRect(100, 100, 500, 200)\n    // }\n}\n\ndrawBackground() {\n    this.ctx.fillStyle = \"black \";\n    this.ctx.fillRect(190, 200, 300, 300);\n}\n\nanimate() {\n    this.obstacle.animate(this.ctx);\n    this.player.animate(this.ctx);\n    \n    if (!this.running ) {\n        this.gameStartMenu(); \n        // this.gameStartMenu();\n    }\n    \n    if (this.gameOver()) {\n      this.obstacle.animate(this.ctx);\n      this.player.drawGameOverSprite(this.ctx);\n      this.gameOverMenu();\n      this.running = false;\n    }\n\n    this.score.draw(this.ctx);\n\n    if (this.running) {  \n      requestAnimationFrame(this.animate.bind(this));\n    }\n  } \n}\n\nmodule.exports = Game;\n\n","const Player = require('./player.js')\nconst Game = require('./game.js')\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    const gameCanvas = document.getElementById(\"game-canvas\");\n    const ctx = gameCanvas.getContext(\"2d\");\n    // gameCanvas.width = 700;\n    // gameCanvas.height = 400;\n\n    const game = new Game(ctx, gameCanvas);\n\n    game.animate();\n\n});\n","const CONSTANTS = {\n    OBSTACLE_WIDTH: 30,\n    SPACING: 500,\n}\n\nconst TREE = {\n    tree1: [10, 103, 150, 150],\n    tree2: [380, 21, 130, 280]\n}\n\nconst ROCK = {\n    rock1: [0, 0, 80, 80]\n}\n\nconst WATER = {\n    water1: [294, 140, 100, 30]\n}\nclass Obstacle {\n    constructor(options) {\n        this.x = 300;\n        this.y = 230;\n        this.speed = 5;\n        this.backgroundx = 0;\n        this.backgroundy = -50;\n\n        this.background = new Image();\n        this.background.src =  './assets/images/forest.png';\n        \n        this.tree = new Image();\n        this.tree.src = './assets/images/trees.png'\n        this.water = new Image();\n        this.water.src = './assets/images/water.png'\n        this.rock = new Image();\n        this.rock.src = './assets/images/boulder1.png'\n\n        const firstObstacleDistance = this.x + 200;\n        this.obstacles = [this.createObstacle(firstObstacleDistance + 210), this.createObstacle(firstObstacleDistance * 2.5 )];\n    }\n\n    createObstacle(x) {\n        // const obstacle = {\n        //     oneObstacle: {  \n        //         left: x,\n        //         right: CONSTANTS.OBSTACLE_WIDTH + x,\n        //         top: this.y,\n        //         bottom: this.y + 130,\n        //         type: this.randomObstacle(2)\n        //     },\n        // }\n        const obstacle = {\n            oneObstacle: {  \n                left: x,\n                right: CONSTANTS.OBSTACLE_WIDTH + x,\n                top: 230,\n                bottom: 360,\n                type: this.randomObstacle(3)\n            },\n        }\n\n\n        return obstacle;\n    }\n\n    eachObstacle(callback){\n        this.obstacles.forEach(callback.bind(this))\n    }\n\n    drawObstacle(ctx) {\n        this.eachObstacle(function(obstacle) {\n            // ctx.beginPath();\n            // ctx.fillStyle = \"orange\";\n            // ctx.fillRect(obstacle.oneObstacle.left  , this.y, 30, 130);\n            // ctx.closePath();\n\n           \n            if (obstacle.oneObstacle.type === 0) {\n                obstacle.oneObstacle.top = 230;\n                obstacle.oneObstacle.bottom = 360;\n                ctx.drawImage(this.tree, TREE.tree1[0], TREE.tree1[1], TREE.tree1[2], TREE.tree1[3], obstacle.oneObstacle.left, this.y - 50, 140, 150)\n            } else if (obstacle.oneObstacle.type === 1) {\n                obstacle.oneObstacle.top = 350;\n                obstacle.oneObstacle.bottom = 450;\n                ctx.drawImage(this.water, WATER.water1[0], WATER.water1[1], WATER.water1[2], WATER.water1[3], obstacle.oneObstacle.left, this.y + 99, 100, 20)\n            } else if (obstacle.oneObstacle.type === 2) {\n                obstacle.oneObstacle.top = 300;\n                obstacle.oneObstacle.bottom = 400;\n                ctx.drawImage(this.rock, ROCK.rock1[0], ROCK.rock1[1], ROCK.rock1[2], ROCK.rock1[3], obstacle.oneObstacle.left, this.y + 30, 100, 80)\n            }\n        })\n    }\n\n    drawObstacle2(ctx) {\n        this.eachObstacle(function(obstacle) {\n                ctx.beginPath();\n                ctx.fillStyle = \"orange\";\n                ctx.fillRect(obstacle.oneObstacle.left, this.y, 30, 130);\n                ctx.closePath();\n            }\n        )\n    }\n\n    randomObstacle(max) {\n        return Math.floor(Math.random() * Math.floor(max))\n    }\n\n    move() {\n        this.eachObstacle(function(obstacle) {\n            obstacle.oneObstacle.left -= this.speed;\n        })\n\n        if (this.obstacles[0].oneObstacle.left <= 0) {\n            this.obstacles.shift();\n            const newObstacle = this.obstacles[0].oneObstacle.left + CONSTANTS.SPACING;\n            this.obstacles.push(this.createObstacle(newObstacle))\n        }\n        // this.x -= this.speed;\n        // ctx.clearRect(25, 350, 400, 70  0);\n    }\n\n    drawBackground(ctx) {\n        ctx.drawImage(this.background, this.backgroundx, this.backgroundy);\n        ctx.drawImage(this.background, this.backgroundx + 700, this.backgroundy);\n        if (this.backgroundx <= -700) {\n            this.backgroundx = 0;\n        }\n        // ctx.drawImage(this.background, this.x + 700, this.y);\n\n        this.moveBackground();\n    }\n\n    moveBackground() {\n        this.backgroundx -= this.speed;\n    }\n\n    animate(ctx) { \n        this.drawBackground(ctx);\n        this.move(ctx);\n        this.drawObstacle(ctx);\n\n\n    }\n\n    checkCollision(player) {\n        const _collision = (obstacleBox, playerBox) => {\n            if (obstacleBox.left > playerBox.right || obstacleBox.right < playerBox.left) {\n                return false;\n            }\n            if (obstacleBox.top  > playerBox.bottom || obstacleBox.bottom < playerBox.top) {\n                return false;\n            }\n\n            return true;\n        };\n\n        let hit = false;\n        this.eachObstacle((obstacle) => {\n            if (_collision(obstacle.oneObstacle, player)) {\n                hit = true;\n            }\n        });\n        return hit;\n    }\n\n}\n\nmodule.exports = Obstacle;","const NARUTO = {\n    run1: [20, 291 , 50, 50],\n    run2: [144, 291, 50, 50],\n    run3: [260, 291, 50, 50],\n    run4: [380, 291, 50, 50],\n    run5: [500, 291, 50, 50],\n    run6: [620, 291, 50, 50],\n    hit: [852, 182, 60, 60]\n\n}\nclass Player {\n  constructor(options) {\n    // this.position = options.position;\n    this.vel = 0;\n    this.x = 25;\n    this.y = 280;\n    this.jumping = false;\n    this.jumpCount = 0;\n    this.jumpTimer = 0;\n    this.runCycle = 0;\n\n    this.spriteSheet = new Image();\n    this.spriteSheet.src = './assets/images/narutosprite.png';\n  }\n\n//   draw(ctx) {\n//     ctx.beginPath();\n//     ctx.fillStyle = \"cyan\";\n//     ctx.fillRect(this.x, this.y, 50, 50);\n//     ctx.closePath();\n//   }\n\n    draw(ctx) {\n        const sprite = this.pickSprite();\n        ctx.drawImage(this.spriteSheet, sprite[0], sprite[1], sprite[2], sprite[3], this.x, this.y -20  , 70, 70)\n    }\n\n\n    pickSprite() {\n        if (this.playerDown) {\n            return NARUTO.hit;\n        } else if (!this.grounded()) {\n            return NARUTO.run6;\n        } else if (this.runCycle < 10) {\n            this.runCycle += 1;\n            return NARUTO.run1;\n        } else if (this.runCycle < 20) {\n            this.runCycle += 1;\n            return NARUTO.run2;\n        } else if (this.runCycle < 30) {\n            this.runCycle += 1;\n            return NARUTO.run3;\n        } else if (this.runCycle < 40) {\n            this.runCycle += 1;\n            return NARUTO.run4;\n        } else if (this.runCycle < 50){\n            this.runCycle += 1;\n            return NARUTO.run5;\n        } else if (this.runCycle < 60){\n            this.runCycle += 1;\n            return NARUTO.run6;\n        } else if (this.runCycle < 70){\n            this.runCycle = 0;\n            return NARUTO.run1;\n        }\n    }\n\n    jump(ctx) {\n        const gravity = 0.4;\n        const initialSpeed = 12;\n\n        if (this.jumping) {\n        ctx.clearRect(this.x, this.y, 40, 0);\n        if (this.jumpCount === 0 || !this.grounded()) {\n            this.y -= initialSpeed - gravity * this.jumpCount;\n            this.jumpCount += 1;\n        }\n        }\n        if (this.jumpCount > 60) {\n        this.y = 280;\n        this.jumpCount = 0;\n        this.jumping = false;\n        }\n    }\n\n    grounded() {\n        return this.x === 25 && this.y >= 280;\n    }\n\n    animate(ctx) {\n        this.jump(ctx);\n        this.draw(ctx);\n    }\n\n    pickGameOverSprite(){\n        return NARUTO.hit;\n    }\n\n    drawGameOverSprite(ctx){\n        const sprite = this.pickGameOverSprite();\n        ctx.drawImage(\n          this.spriteSheet,\n          sprite[0],\n          sprite[1],\n          sprite[2],\n          sprite[3],\n          this.x,\n          this.y - 20,\n          70,\n          70\n        );\n    }\n\n    playerHitBox() {\n        return {\n            left: this.x,\n            right: this.x + 60,\n            top: this.y,\n            bottom: this.y + 70,\n        }\n    }\n}\n\nmodule.exports = Player;\n","class Score { \n    constructor() {\n        this.score = 0;\n    }\n\n    draw(ctx) {\n        const yourScore = `${this.score}`;\n        ctx.font = \"30px Naruto\";\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = 2;\n        ctx.fillStyle = \"white\";\n        ctx.textAlign = \"left\";\n        ctx.strokeText(yourScore, 10, 40);\n        ctx.fillText(yourScore, 10, 40);\n        this.increaseScore();\n    }\n\n    increaseScore() {\n        this.score += 1;\n    }\n}\n\nmodule.exports = Score;"],"sourceRoot":""}